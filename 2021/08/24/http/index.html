<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="referrer" content="no-referrer">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="theme-color" content="#3367D6" />
    <link rel="apple-touch-icon" href="/icons-192.png">
    <link rel="manifest" href="/manifest.json">

    <meta name="generator" content="Hexo 5.4.0">

        
            <meta name="description" content="钱端之路无止尽">
            

                

                        
                            <meta name="author" content="广工彭于晏">
                            

                                

                                        

                                            <title>
                                                
                                                    http |
                                                        
                                                            Flower &amp; Alice
                                            </title>

                                            

                                                    
                                                        <link rel="shortcut icon" href="/favicon.ico">
                                                            

                                                                
                                                                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@1.1.3/index.min.css">
                                                                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs@9.16.2/styles/monokai.css">
                                                                    

                                                                        
<link rel="stylesheet" href="/css/style.css">

</head>

<body>
    <div class="root-container">
        
<!-- header container -->
<header class="header-container post">
  
    <div class="post-image" style="background-image: url(https://pic.imgdb.cn/item/6124a30e44eaada739124698.jpg)"></div>
  

  <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          Flower &amp; Alice
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">首页</a></li>
        
          <li class="navbar-list-item"><a href="/links">友链</a></li>
        
          <li class="navbar-list-item"><a href="/about">关于</a></li>
        
      </ul>
    </div>
  </div>
</nav>

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-text layout-block">
        <div class="layout-margin">
          <h1 class="title-wrap">http</h1>
          <h2 class="title-sub-wrap">
            <strong>广工彭于晏</strong>
            <span>发布于</span>
            <time  class="article-date" datetime="2021-08-24T07:42:25.000Z" itemprop="datePublished">2021-08-24</time>
          </h2>
          <ul class="wrap-list dark">
  
</ul>
          <ul class="wrap-list dark">
  
    <li><a href="/tags/http/">🏷️ http</a></li>
  
</ul>
        </div>
      </div>
    </div>
  

  
  
  
</header>

            <!-- 文章 -->

<!-- 文章内容 -->
<div class="body-container">
  <article class="content-container layout-block post-container">
    <div class="article-info">
      
      
      
      
      <section class="article-entry markdown-body layout-margin content-padding--large soft-size--large soft-style--box">
        <h3 id="Cookie的存活时间"><a href="#Cookie的存活时间" class="headerlink" title="Cookie的存活时间"></a>Cookie的存活时间</h3><ul>
<li><p><strong>浏览器端</strong>：cookie(小,设置过期时间来间接清除) ,WebStorage(localStorage(大,方便,内容不会随请求发给服务器)、sessionStorage),  userData(IE) ,  indexedDB                                          </p>
<p><strong>服务器端：</strong> session</p>
</li>
<li><p>默认情况下,cookie数据保存到内存里,浏览器关闭后,Cookie数据被销毁</p>
</li>
<li><p>持久化存储 : setMaxAge(int seconds)</p>
<p>① 正数  :  将Cookie数据写到硬盘的文件中，持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效。 (若不关闭浏览器,则仍可访问cookie)</p>
<p>② 负数  :  默认值，即关闭浏览器后，cookie即失效</p>
<p>③ 零      :  删除cookie信息</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/617278e52ab3f51d91c46e43.jpg"></p>
<hr>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li><p>同源策略</p>
<ul>
<li> 指的是浏览器对不同源的脚本或者文本的访问方式进行的限制</li>
<li> 同源是指”协议+域名+端口”三者相同</li>
<li>它能帮助阻隔恶意文档, 避开 XSS、 CSFR 等攻击。<ul>
<li> Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li> DOM 无法获得。</li>
<li> AJAX 请求不能发送。</li>
</ul>
</li>
</ul>
</li>
<li><p>不受同源策略限制的：</p>
<ul>
<li>页面中的链接，重定向以及表单提交是不会受到同源策略限制的。</li>
<li>跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的&lt;script src=”…”&gt;, &lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;等。</li>
</ul>
</li>
<li><p>如何跨域</p>
<ul>
<li><p>jsonp  </p>
<ul>
<li>网页通过添加一个<code>&lt;script&gt;</code>元素，向跨源网址请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</li>
<li>只能GET, 还有安全性问题,用字符串过滤规避 </li>
</ul>
</li>
<li><p>CORS（Cross-origin resource sharing） :  </p>
<ul>
<li>CORS请求设置的响应头字段,都以Access-Control开头</li>
<li>在响应头上添加Access-Control-Allow-Origin属性，指定同源策略的地址。同源策略默认地址是网页的本身。只要浏览器检测到响应头带上了CORS，并且允许的源包括了本网站，那么就不会拦截请求响应。</li>
</ul>
</li>
<li><p>websocket</p>
</li>
<li><p>降域 document.domain</p>
</li>
<li><p>nginx</p>
</li>
<li><p>window.name</p>
<p>( 浏览器窗口有<code>window.name</code>属性。无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。优点是，<code>window.name</code>容量很大，可以放置非常长的字符串；缺点是必须监听子窗口<code>window.name</code>属性的变化，影响网页性能。 )</p>
</li>
<li><p>跨文档通信 API, <code>window.postMessage</code>方法</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h5 id="1）计算机网络参考模型："><a href="#1）计算机网络参考模型：" class="headerlink" title="1）计算机网络参考模型："></a>1）计算机网络参考模型：</h5><ul>
<li>ISO/OSI 模型：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层</li>
<li>TCP/IP 模型：主机至网络层，互联网层，传输层，应用层</li>
<li>计网课本模型：物理层，数据链路层，网络层，传输层，应用层</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/614dd4952ab3f51d9152ab61.jpg"></p>
<hr>
<p>2）各层作用：</p>
<ul>
<li>应用层：应用层提供各种各样的应用层协议HTTP、FTP、SMTP、TELNET，这些协议嵌入在各种我们使用的应用程序中，为用户与网络之间提供打交道的接口，并提供稳定的通信接口和终端用户服务。</li>
<li>表示层：将应用处理的信息转换为适合网络传输的格式</li>
<li>会话层： 建立和管理本地主机和远程主机之间的会话</li>
<li>传输层：为上层协议提供端到端的可靠和透明的数据传输服务，处理差错控制和流量控制，保证报文的正确传输；1.面向连接的数据传输服务（TCP） 2.无连接的数据传输服务（UDP）</li>
<li>网络层：根据逻辑地址寻址,交换,路由算法,连接服务 ( IP / ICMP )</li>
<li>数据链路层：（LLC）把来自网络层的数据可靠的传输至相邻节点的网络层</li>
<li>物理层：建立、维护、断开物理连接，完成传输媒体的信号与二进制信号的转换（比特流）</li>
</ul>
<hr>
<p>3）为什么要分层：</p>
<ul>
<li>易于实现和标准化各层独立，就可以把大问题分割成多个小问题，利于实现；</li>
<li>灵活性好：如果某一层发生变化，只要接口不变，不会影响其他层；</li>
<li>分层后，用户只关心用到的应用层，其他层用户可以复用；</li>
<li>各层之间相互独立：高层不需要知道底层的功能是采取硬件来实现的，只需要知道通过底层的接口来获得所需要的服务。</li>
</ul>
<hr>
<p>4）数据链路层怎么实现可靠性传输：</p>
<ul>
<li>数据帧会通过一些手段对数据进行校验，来发现数据帧是否错误，如果错误，可以检错重发，向前纠错，反馈校验，检错丢弃等手段来保证两个节点之间传输的数据帧向上层提供的数据是无差错的。常见的检错编码有奇偶校验码和循环冗余码。</li>
<li>奇偶校验码是奇校验码和偶校验码的统称，是一种最基本的检错码。它由n-1位信息元和1位校验元组成，如果是奇校验码，那么在附加一个校验元后，码元为n的码字中“1”的个数为奇数，如果是偶数校验码，那么在附加一个校验元以后，码元为n的码字中“1”的个数为偶数。</li>
<li>循环冗余码（Cyclic Redundancy Code,CRC）又称多项式码，基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的余数作为校验数据附加到原数据后面。</li>
</ul>
<hr>
<p>5）交换机和路由器区别：</p>
<ul>
<li>路由器在网络层，路由器根据IP地址寻址，路由器可以处理TCP/IP协议，交换机不可以。交换机在数据链路层，交换机根据MAC地址寻址。</li>
<li>路由器能将一个IP分配给超多个主机使用，主机对外ip也是同一个。而交换机是可以将不同的主机连接起来，对外表现的IP也可各有不同。</li>
<li>路由器提供防火墙的服务，交换机不能提供该功能。集线器、交换机都是做端口扩展的，就是扩大局域网(通常都是以太网)的接入点，也就是能让局域网可以连进来更多的电脑。路由器是用来做网间连接，也就是用来连接不同的网络。</li>
</ul>
<hr>
<p>6）代理服务器和网关的区别：</p>
<ul>
<li>网关：如果两个网络要进行通讯，那么每个网络都需要一个网关。网关区分了一个网络的内部和外部。如果一台电脑需要访问网络外的其他电脑，那么就需要配置网关来获得访问网络外部的权限。如果没有网关，电脑就无法访问局域网之外的网络部分，就像是被锁在家里一样。</li>
<li>代理服务器：对于网络外部来说，代理服务器代表了整个内部网络。任何用户想访问带有代理服务器的网络，都只能看到代理服务器的IP。当把电脑的Internet选项配置成通过代理服务器访问因特网，代理服务器就能隐藏你的网络信息。它使网络内部的电脑变成匿名的。</li>
<li>功能区别：如果代理服务器不做任何信息过滤，那么它就和网关一样，传递从电脑到因特网的请求。然后代理服务器是一个比网关更强大的网络组建，除了有网关的功能之外，还能保护网络免受外部的威胁。网关却有暴露网络内部信息的危险，因为它没有任何过滤机制。它仅仅把网络内的信息发送到网络外。</li>
</ul>
<hr>
<h3 id="协议指南"><a href="#协议指南" class="headerlink" title="协议指南"></a>协议指南</h3><ul>
<li>网络层：<ul>
<li>IP ：网络之间互连的协议<ul>
<li>IPV4 与 IPV6 的改进：更大的地址空间（32位到128位），允许协议继续扩充，增大了安全性</li>
</ul>
</li>
<li>ARP：完成 IP 地址到 MAC 地址的映射<ul>
<li>原因：由于在实际网络的链路上传送数据帧，最终必须使用硬件地址</li>
<li>原理：每台主机都设有一个 ARP 高速缓存，用来存放本局域网上各主机和路由器的 IP 到 MAC 地址的映射表 APR 表。当主机 A 向主机 B 发送 IP 数据报时，先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址，如果没有，就使用 MAC 地址为 FF-FF-FF-FF-FF-FF 的帧来封装并广播 ARP 请求分组，使同一个局域网里的所有主机收到 ARP 请求。</li>
</ul>
</li>
<li>ICMP：让主机或路由器报告差错和异常情况<ul>
<li>五种差错报告报文：终点不可达，源点抑制（使源点的发送速率放慢），时间超过，参数问题，改变路由（下次将数据包发送给另外的路由器）</li>
<li>ping 命令：用来测试两台主机之间的连通性，源主机会发送一份 ICMP 回显请求报文给目标主机，并等待目标主机返回 ICMP 回显应答。如果源主机在一定时间内收到了目标主机的应答，则表明两台主机之间网络是可达的。</li>
<li>tracert/traceroute 命令：Tracert每次发出数据报时便会将TTL加1，经过一个路由器就减1，通过这样来发现下一个路由器。这个动作一直重复，直到到达目的地或者确定目标主机不可到达为止。</li>
</ul>
</li>
<li>OSPF：内部网关协议，路由选择协议<ul>
<li>原理：使用迪利克斯算法计算从自己到各目的网络的最优路径，从而构造自己的路由表。</li>
<li>与 RIP 协议的区别：OSPF 向本自治系统中的所有路由器发送信息；发送的信息是本路由器相邻的所有路由器的链路状态；只有当链路状态发生变化的时候，才会更新状态</li>
<li>五种分组类型：问候分组（发现可达性），数据库描述分组（给出自己的链路状态数据库的摘要信息），链路状态请求分组（发送链路状态的详细信息），链路状态更新分组（对全网更新链路状态），链路状态确认分组</li>
</ul>
</li>
<li>IGMP：使路由器知道组播成员的信息<ul>
<li>原理：当某台主机要加入新的组播组时，该主机应向组播组的组播地址发送一个 IGMP 报文，声明自己要成为该组的成员。当本地的组播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他组播路由器。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>传输层：<ul>
<li>UDP：用户数据报协议<ul>
<li>无须建立连接，无连接状态，分组首部开销小（8B，源端口，目的端口，长度，校验和），不可靠（可以在应用层进行可靠性工作的维护）</li>
<li>常用于多媒体应用（如 IP 电话、实时视频会议、流媒体等）</li>
</ul>
</li>
<li>TCP：传输控制协议<ul>
<li>面向连接，每条连接只能是点对点的，提供可靠的交付服务</li>
<li>TCP一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等</li>
</ul>
</li>
<li>DHCP：动态主机配置协议，用于给主机动态分配 IP 地址，基于 UDP<ul>
<li>原理：使用客户/服务器方式，需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送报文，这时主机就成为 DHCP 客户，本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才能回答此报文。</li>
</ul>
</li>
<li>RIP：内部网关协议，路由选择协议，基于 UDP<ul>
<li>与 OSPF 的区别：仅和相邻路由器交换信息；交换的信息是当前路由器所知道的全部信息；按固定时间间隔交换路由信息。</li>
<li>优点：实现简单，开销小，收敛过程较快。</li>
<li>缺点：RIP 限制了网络规模，最大距离为15；交换的是完整路由表，网络规模越大，开销越大；网络出现故障时，会出现慢收敛现象。</li>
</ul>
</li>
<li>BGP：边界网关协议，基于 TCP<ul>
<li>原理：一个 BGP 的路由器与其他自治系统的 BGP 路由器要交换路由信息，首先要建立 TCP 连接，建立 BGP 会话，然后利用会话交换路由信息，当所有 BGP 路由器都交换网络可达性信息后，各个 BGP 路由器就可以找出各个自治系统的较好路由。</li>
<li>四种报文：打开报文（建立关系），更新报文（发送路由信息），保活报文（确认打开报文），通知报文（发送检测到的差错）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>应用层：<ul>
<li>DNS：将特定含义的主机名转换为 IP 地址<ul>
<li>采用客户/服务器模型，运行在 UDP 上，使用53端口</li>
<li>域名：顶级域名，一级域名，二级域名，三级域名…</li>
<li>域名服务器：根域名服务器，顶级域名服务器，授权域名服务器，本地域名服务器</li>
<li>当客户端需要域名解析的时候，通过本机的 DNS 客户端构造一个 DNS 请求报文，以 UDP 数据变方式发往本地域名服务器</li>
<li>域名解析有两种方式：递归查询和递归与迭代相结合的查询</li>
</ul>
</li>
<li>FTP：文件传输协议<ul>
<li>采用客户/服务器模型，运行在 TCP 上</li>
<li>功能：提供不同种类主机系统之间的文件传输能力；以用户权限管理的方式提供用户对远程 FTP 服务器上的文件管理能力；以匿名 FTP 的方式提供公用文件共享的能力</li>
<li>进程分为两个，一个主进程，负责接收新的请求；另外若干从属进程，负责处理单个请求</li>
<li>工作时使用两个并行的 TCP 连接，一个控制连接（端口号 21），一个数据连接（端口号 20）</li>
</ul>
</li>
<li>STMP：简单邮件传输协议，控制两个相互通信的 STMP 进程交换信息<ul>
<li>使用的是 TCP 连接，端口号为 25</li>
<li>三个阶段：<ul>
<li>连接建立：发现有邮件，使用 SMTP 的熟知端口号 25 与接收方邮件服务器的 STMP 服务区建立 TCP 连接。接收方 STMP 服务器发出 220 Service（服务就绪），然后 STMP 客户向 STMP 服务器发送 HELLO 命令，附上发送方的主机名。</li>
<li>邮件传送</li>
<li>连接释放：邮件发送完毕后，SMTP 客户应发送 QUIT 命令，SMTP 服务器返回的信息是 221（服务关闭），表示 SMTP 同意释放 TCP 连接</li>
</ul>
</li>
</ul>
</li>
<li>POP3：邮件读取协议<ul>
<li>采用 “拉” 的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，“拉” 取用户邮箱中的邮件</li>
<li>使用客户/服务器的工作方式，使用 TCP 连接，端口号为 110</li>
</ul>
</li>
<li>IMAP：报文存取协议<ul>
<li>比 POP 复杂很多，IMAP 为用户提供了创建文件夹，在不同文件夹之间移动邮件及在远程文件夹中查询邮件等联机命令</li>
</ul>
</li>
<li>HTTP：超文本传输协议<ul>
<li>定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器</li>
<li>基于 TCP 协议，默认端口 80</li>
<li>无连接：通信双方在交换 HTTP 报文之前不需要先建立 HTTP 连接</li>
<li>无状态：同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时相同</li>
<li>使用 Cookie 加数据库的方式来跟踪用户的活动，原理：当用户浏览某个使用 Cookie 的网站时，该网站就为用户产生一个唯一的识别码，接着在给用户的响应报文中添加一个 Set-cookie 的首部行。用户收到这个响应报文后，就在它管理的特定 Cookie 文件中添加这个服务器的主机名和 Cookie 识别码。</li>
<li>支持非持久连接：每个网页元素对象的传输都需要单独建立一个 TCP 连接</li>
<li>支持持久连接（1.1）：万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求和响应报文</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>1）IPv4：</p>
<ul>
<li>首部长度为20B，包含：版本，首部长度，总长度，标识，标志，片位移，生存时间，协议，首部校验和，源地址字段，目的地址字段</li>
<li>IPv4地址：<ul>
<li>根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用，如A类中的0.0.0.0和127.255.255.255都不使用。</li>
<li>A类：(1.0.0.1-126.255.255.254)（默认子网掩码：255.0.0.0或0xFF000000）第一个字节为网络号，后三个字节为主机号，表示为网络–主机–主机–主机。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。共有16777214个主机地址，一般用于大型网络。</li>
<li>B类：(128.1.0.1-191.254.255.254)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。共有65534个主机地址，一般用于中等规模网络。</li>
<li>C类：(192.0.1.1-223.255.254.254)（子网掩码：255.255.255.0或0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。共有254个主机地址，一般用于小型网络。</li>
<li>D类：是多播地址。(224.0.0.1-239.255.255.254) 该类IP地址的前面4位为“1110”，所以网络号取值于224~239之间；后面28位为组播地址ID。这是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicasting）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。</li>
<li>E类：是保留地址，为将来使用保留。(240.0.0.0—255.255.255.254) 该类IP地址的最前面为“1111”，所以网络号取值于240~255之间。</li>
<li>注意：所有的网络空间计算都必须 -2，这是因为要扣除两个保留地址：</li>
<li>主机号全部为1的地址是子网广播地址，如：192.168.1.255 ；</li>
<li>主机号全部为0的地址是代表该子网的网络地址，如：192.168.1.0 ；</li>
<li>1-254才是给主机使用的。</li>
</ul>
</li>
<li>特殊地址：主机号全零是本网络，主机号全一是本网络的广播地址，127.0.0.0 表示任意主机本身，32 位全零是本网络上的本主机，32 位全一表示整个 TCP/IP 网络的广播地址</li>
<li>两级 IP 地址利用率较低，于是出现了子网掩码，将 IP 地址和其独赢的子网掩码逐位 “与” （逻辑 AND 运算），就可得出相应子网的网络地址；而后又出现了无分类域间路由（CIDR），消除了传统 A，B，C 和子网的概念，通过逐位与得到该地址的网络前缀</li>
</ul>
<hr>
<p>2）IPv6：</p>
<ul>
<li>目的地址有下面三种：<ul>
<li>单播，传统的点对点通信</li>
<li>多播，一对多点的通信，分组被交付到一组计算机的每台计算机</li>
<li>任播：目的站是一组计算机，但在交付时只交付一台，通常是最远的一台</li>
</ul>
</li>
<li>IPv4 向 IPv6 过渡方式：<ul>
<li>双协议栈：一台设备上同时装有 IPv4 和 IPv6 协议栈，那么这台设备既能和 IPv4 网络通信，也能和 IPv6 网络通信。</li>
<li>隧道技术：整个 IPv6 数据报封装到 IPv4 数据报的数据部分，使得 IPv6 数据报能在 IPv4 网络的隧道中传输。</li>
</ul>
</li>
</ul>
<hr>
<p>3）有 IP 地址，为什么需要 MAC 地址？</p>
<ul>
<li>由于IP只是逻辑上标识，任何人都随意修改，因此不能用来标识用户；而 MAC地址则不然，它是固化在网卡里面的。基于MAC地址的这种特点，局域网采用了用MAC地址来标识具体用户的方法。注意：具体实现：在交换机内部通过“表”的方式把MAC地址和IP地址一一对应，也就是所说的IP、MAC绑定。</li>
<li>接收过程，当有发给本地局域网内一台主机的数据包时，交换机接收下来，然后把数据包中的IP地址按照 “表” 中的对应关系映射成MAC地址，转发到对应的MAC地址的主机上，这样一来，即使某台主机盗用了这个IP地址，但由于他没有这个MAC地址，因此也不会收到数据包。</li>
</ul>
<hr>
<p>4）IP 和 TCP 的关系：</p>
<ul>
<li>整个网络中的传输流程是：IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层—TCP层；相反，IP层也把从TCP接收来的数据包传送到更低层。</li>
<li>TCP和IP的关系是：IP提供基本的数据传送，而高层的TCP对这些数据包做进一步加工，如提供端口号等等。</li>
</ul>
<hr>
<p>5）IP 数据报格式：</p>
<ul>
<li>版本（version）：占 4 位，表示 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。目前广泛使用的IP协议版本号为 4，即 IPv4。</li>
<li>首部长度（网际报头长度IHL）：占 4 位，可表示的最大十进制数值是 15。这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节）。因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是，长度有时可能不够用，之所以限制长度为 60 字节，是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。</li>
<li>区分服务（tos）：也被称为服务类型，占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务（Differentiated Services，DS）。只有在使用区分服务时，这个字段才起作用。</li>
<li>总长度（totlen）：首部和数据之和，单位为字节。总长度字段为 16 位，因此数据报的最大长度为 2^16-1=65535 字节。</li>
<li>标识（identification）：用来标识数据报，占 16 位。IP 协议在存储器中维持一个计数器。每产生一个数据报，计数器就加 1，并将此值赋给标识字段。当数据报的长度超过网络的 MTU，而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。具有相同的标识字段值的分片报文会被重组成原来的数据报。</li>
<li>标志（flag）：占 3 位。第一位未使用，其值为 0。第二位称为 DF（不分片），表示是否允许分片。取值为 0 时，表示允许分片；取值为 1 时，表示不允许分片。第三位称为 MF（更多分片），表示是否还有分片正在传输，设置为 0 时，表示没有更多分片需要发送，或数据报没有分片。</li>
<li>片偏移（offsetfrag）：占 13 位。当报文被分片后，该字段标记该分片在原报文中的相对位置。片偏移以 8 个字节为偏移单位。所以，除了最后一个分片，其他分片的偏移值都是 8 字节（64 位）的整数倍。</li>
<li>生存时间（TTL）：表示数据报在网络中的寿命，占 8 位。该字段由发出数据报的源主机设置。其目的是防止无法交付的数据报无限制地在网络中传输，从而消耗网络资源。路由器在转发数据报之前，先把 TTL 值减 1。若 TTL 值减少到 0，则丢弃这个数据报，不再转发。因此，TTL 指明数据报在网络中最多可经过多少个路由器。TTL 的最大数值为 255。若把 TTL 的初始值设为 1，则表示这个数据报只能在本局域网中传送。 </li>
<li>协议：表示该数据报文所携带的数据所使用的协议类型，占 8 位。该字段可以方便目的主机的 IP 层知道按照什么协议来处理数据部分。不同的协议有专门不同的协议号。例如，TCP 的协议号为 6，UDP 的协议号为 17，ICMP 的协议号为 1。</li>
<li>首部检验和（checksum）：用于校验数据报的首部，占 16 位。数据报每经过一个路由器，首部的字段都可能发生变化（如TTL），所以需要重新校验。而数据部分不发生变化，所以不用重新生成校验值。</li>
<li>源地址：表示数据报的源 IP 地址，占 32 位。</li>
<li>目的地址：表示数据报的目的 IP 地址，占 32 位。该字段用于校验发送是否正确。</li>
<li>可选字段：该字段用于一些可选的报头设置，主要用于测试、调试和安全的目的。这些选项包括严格源路由（数据报必须经过指定的路由）、网际时间戳（经过每个路由器时的时间戳记录）和安全限制。</li>
<li>填充：由于可选字段中的长度不是固定的，使用若干个 0 填充该字段，可以保证整个报头的长度是 32 位的整数倍。</li>
<li>数据部分：表示传输层的数据，如保存 TCP、UDP、ICMP 或 IGMP 的数据。数据部分的长度不固定。</li>
</ul>
<hr>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h5 id="1）TCP-和-UDP-的区别："><a href="#1）TCP-和-UDP-的区别：" class="headerlink" title="1）TCP 和 UDP 的区别："></a>1）TCP 和 UDP 的区别：</h5><ul>
<li>TCP 面向连接，UDP 是无连接的</li>
<li>TCP 提供可靠性传输，UDP 是尽最大努力交付</li>
<li>TCP 要建立连接才能进行传输，速度慢于 UDP</li>
</ul>
<h5 id="2）UDP-如何实现可靠性传输："><a href="#2）UDP-如何实现可靠性传输：" class="headerlink" title="2）UDP 如何实现可靠性传输："></a>2）UDP 如何实现可靠性传输：</h5><ul>
<li><p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p>
<ul>
<li>添加seq/ack机制，确保数据发送到对端</li>
<li>添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>添加超时重传机制。</li>
</ul>
</li>
<li><p>开源程序：</p>
<ul>
<li>RUDP 提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。</li>
<li>RTP为数据提供了具有实时特征的端对端传送服务，如在组播或单播网络服务下的交互式视频音频或模拟数据。RTP 并不保证传送或防止无序传送，也不确定底层网络的可靠性。 RTP 实行有序传送， RTP 中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。</li>
<li>UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。</li>
</ul>
</li>
</ul>
<p>3）UDP 的适用场景：</p>
<ul>
<li>当对网络通讯质量要求不高时，要求网络通讯的速度能尽量的快，这时就可以适用 UDP<ul>
<li>视频聊天，语音聊天</li>
</ul>
</li>
</ul>
<p>4）面向连接和无连接的区别：</p>
<ul>
<li>指的是协议，本质区别在于：对于无连接协议来说，每个分组的处理都独立于其他的分组。而对于面向连接的协议，协议实现维护了当前分组与后继分组有关的状态信息。</li>
</ul>
<p>5）视频传输用 TCP 还是 UDP：</p>
<ul>
<li>由于TCP是面向连接的传输层协议，它的重传机制和拥塞控制机制，将使网络状况进一步恶化，从而带来灾难性的延时。同时，在这种网络环境下，通过TCP传输的视频数据，在接收端重建、回放时，断点非常明显，体现为明显的断断续续，传输的实时性和传输质量都无法保障。</li>
<li>相对而言，采用RTP传输的视频数据的实时性和传输质量就要好得多。RTP（Real-Time Transport Protocol）/RTCP（Real-Time Transport Control Protocol）是一种应用型的传输层协议，它并不提供任何传输可靠性的保证和流量的拥塞控制机制。它是由IETF（Internet Engineering Task Force）为视音频的实时传输而设计的传输协议。</li>
<li>RTP协议位于UDP协议之上，在功能上独立于下面的传输层（UDP）和网络层，但不能单独作为一个层次存在，通常是利用低层的UDP协议对实时视音频数据进行组播（Multicast）或单播（Unicast）,从而实现多点或单点视音频数据的传输。</li>
</ul>
<p>6）UDP 报文格式：</p>
<ul>
<li>每个 UDP 报文分为 UDP 报头和 UDP 数据区两部分。报头由 4 个 16 位长（2 字节）字段组成，分别说明该报文的源端口、目的端口、报文长度和校验值。</li>
<li>源端口：这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口。接收端的应用程序利用这个字段的值作为发送响应的目的地址。这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中。如果不写入端口号，则把这个字段设置为 0。这样，接收端的应用程序就不能发送响应了。</li>
<li>目的端口：接收端计算机上 UDP 软件使用的端口，占据 16 位。</li>
<li>长度：该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度。因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8。</li>
<li>校验值：该字段占据 16 位，可以检验数据在传输过程中是否被损坏。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="D:\不可描述\课设\image\三次握手.png"></p>
<p>1）主动发起连接建立的进程称为客户，而被动等待连接建立的应用进程称为服务器</p>
<h5 id="2）过程：为了保证数据能到达目标，TCP采用三次握手策略。"><a href="#2）过程：为了保证数据能到达目标，TCP采用三次握手策略。" class="headerlink" title="2）过程：为了保证数据能到达目标，TCP采用三次握手策略。"></a>2）过程：为了保证数据能到达目标，TCP采用三次握手策略。</h5><ol>
<li>发送端首先发送一个带SYN标志的数据包给接收方【第一次的seq序列号是随机产生的，这样是为了网络安全，如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间的初始化序列号，并且伪造序列号进行攻击】</li>
<li>接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息【SYN 是为了告诉发送端，发送方到接收方的通道没问题；ACK 用来验证接收方到发送方的通道没问题】</li>
<li>最后，发送端再回传一个带ACK标志的数据包，代表握手结束，若在握手某个过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</li>
</ol>
<h5 id="3）为什么要三次握手？"><a href="#3）为什么要三次握手？" class="headerlink" title="3）为什么要三次握手？"></a>3）为什么要三次握手？</h5><ul>
<li>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的</li>
</ul>
<h5 id="4）两次握手不行吗？为什么TCP客户端最后还要发送一次确认呢？"><a href="#4）两次握手不行吗？为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="4）两次握手不行吗？为什么TCP客户端最后还要发送一次确认呢？"></a>4）两次握手不行吗？为什么TCP客户端最后还要发送一次确认呢？</h5><ul>
<li>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。经典场景：客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了。滞留的那一次请求连接，网络通畅了到达服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</li>
</ul>
<p>5）为什么三次握手，返回时，ack 值是 seq 加 1（ack = x+1）</p>
<ul>
<li>确认收到的序列，并且告诉发送端下一次发送的序列号从哪里开始（便于接收方对数据排序，便于选择重传）</li>
</ul>
<p>6）SYN洪泛攻击(SYN Flood，半开放攻击)，怎么解决？</p>
<ul>
<li><p>SYN Flood利用TCP协议缺陷，发送大量伪造的TCP连接请求，常用假冒的IP或IP号段发来海量的请求连接的第一个握手包（SYN包），被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。导致被攻击服务器保持大量SYN_RECV状态的“半连接”，并且会重试默认5次回应第二个握手包，大量随机的恶意syn占满了未完成连接队列，导致正常合法的syn排不上队列，让正常的业务请求连接不进来。</p>
</li>
<li><p>SYN cookies技术：</p>
<ul>
<li>当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源 Id，目的 Id，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</li>
</ul>
</li>
<li><p>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源</p>
</li>
</ul>
<p>7）TCP三次握手中，最后一次回复丢失，会发生什么？</p>
<ul>
<li><p>如果最后一次ACK在网络中丢失，那么Server端（服务端）该TCP连接的状态仍为SYN_RECV，并且根据 TCP的超时重传机制依次等待3秒、6秒、12秒后重新发送 SYN+ACK 包，以便 Client（客户端）重新发送ACK包</p>
</li>
<li><p>如果重发指定次数后，仍然未收到ACK应答，那么一段时间后，Server（服务端）自动关闭这个连接</p>
</li>
<li><p>但是Client（客户端）认为这个连接已经建立，如果Client（客户端）端向Server（服务端）发送数据，Server端（服务端）将以RST包（Reset，标示复位，用于异常的关闭连接）响应，此时，客户端知道第三次握手失败</p>
</li>
</ul>
<p>8）如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>
<ul>
<li>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="D:\不可描述\课设\image\四次挥手.png"></p>
<p>1）参与 TCP 连接的两个进程中的任意一个都能终止该连接</p>
<h5 id="2）过程："><a href="#2）过程：" class="headerlink" title="2）过程："></a>2）过程：</h5><ul>
<li>主动断开方（客户端/服务端）-发送一个 FIN，用来关闭主动断开方（客户端/服务端）到被动断开方（客户端/服务端）的数据传送</li>
<li>被动断开方（客户端/服务端）-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>被动点开方（客户端/服务端）-关闭与主动断开方（客户端/服务端）的连接，发送一个FIN给主动断开方（客户端/服务端）</li>
<li>主动断开方（客户端/服务端）-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h5 id="3）为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#3）为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="3）为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>3）为什么连接的时候是三次握手，关闭的时候却是四次握手？</h5><ul>
<li>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</li>
<li>关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了,所以服务器可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接。因此，服务器ACK和FIN一般都会分开发送，从而导致多了一次。</li>
</ul>
<h5 id="4）为什么TCP挥手每两次中间有一个-FIN-WAIT2等待时间？"><a href="#4）为什么TCP挥手每两次中间有一个-FIN-WAIT2等待时间？" class="headerlink" title="4）为什么TCP挥手每两次中间有一个 FIN-WAIT2等待时间？"></a>4）为什么TCP挥手每两次中间有一个 FIN-WAIT2等待时间？</h5><ul>
<li>主动关闭的一端调用完close以后（即发FIN给被动关闭的一端， 并且收到其对FIN的确认ACK）则进入FIN_WAIT_2状态。如果这个时候因为网络突然断掉、被动关闭的一端宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的FIN（防止对端不发送关闭连接的FIN包给本端），这个时候就需要FIN_WAIT_2定时器， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的FIN，那么直接释放这个链接，进入CLOSE状态</li>
</ul>
<h5 id="5）为什么客户端最后还要等待2MSL？为什么还有个TIME-WAIT的时间等待？"><a href="#5）为什么客户端最后还要等待2MSL？为什么还有个TIME-WAIT的时间等待？" class="headerlink" title="5）为什么客户端最后还要等待2MSL？为什么还有个TIME-WAIT的时间等待？"></a>5）为什么客户端最后还要等待2MSL？为什么还有个TIME-WAIT的时间等待？</h5><ul>
<li><p>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，服务器已经发送了FIN+ACK报文，请求断开，客户端却没有回应，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
</li>
<li><p>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样新的连接中不会出现旧连接的请求报文。</p>
</li>
<li><p>2MSL，最大报文生存时间，一个MSL 30 秒，2MSL = 60s，MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等</p>
</li>
</ul>
<p>6）客户端 TIME-WAIT 状态过多会产生什么后果？怎样处理？</p>
<ul>
<li><p>作为服务器，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，占据大量的tuple /tApl/ ，严重消耗着服务器的资源，此时部分客户端就会显示连接不上</p>
</li>
<li><p>作为客户端，短时间内大量的短连接，会大量消耗的Client机器的端口，毕竟端口只有65535个，端口被耗尽了，后续就无法在发起新的连接了</p>
</li>
<li><p>解决方法：</p>
<ul>
<li>用负载均衡来抗这些高并发的短请求；</li>
<li>服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，TIME_WAIT 状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的</li>
<li>强制关闭，发送 RST 包越过TIMEWAIT状态，直接进入CLOSED状态</li>
</ul>
</li>
</ul>
<p>7）服务器出现了大量 CLOSE_WAIT 状态如何解决？</p>
<ul>
<li>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。</li>
</ul>
<p>8）服务端会有一个TIME_WAIT状态吗？如果是服务端主动断开连接呢？</p>
<ul>
<li><p>发起链接的主动方基本都是客户端，但是断开连接的主动方服务器和客户端都可以充当，也就是说，只要是主动断开连接的，就会有 TIME_WAIT状态</p>
</li>
<li><p>四次挥手是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发</p>
</li>
<li><p>由于TCP连接时全双工的，因此，每个方向的数据传输通道都必须要单独进行关闭。</p>
</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h5 id="1）TCP-如何保证可靠性传输："><a href="#1）TCP-如何保证可靠性传输：" class="headerlink" title="1）TCP 如何保证可靠性传输："></a>1）TCP 如何保证可靠性传输：</h5><ul>
<li>校验和</li>
<li>序号</li>
<li>确认</li>
<li>重传</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<p>2）校验和：</p>
<ul>
<li><p>发送方生成校验和：</p>
<ul>
<li>将待发送数据分成若干个16位的位串，每个位串看成一个二进制数，这里并不管位串代表什么，可以是整数、浮点数、或者位图；</li>
<li>将IP、UDP、TCP的PDU首部中的校验和字段置为0，该字段也参与校验和运算；</li>
<li>对这些16位的二进制数进行1的补码和运算，累加的结果再取反码即生成了校验码，将校验码放入校验和字段中。（其中1的补码和运算，即带循环进位的加法，最高位有进位则循环进到最低位；反码即二进制各位取反，如0111的反码为1000。）</li>
</ul>
</li>
<li><p>接收方校验校验和：</p>
<ul>
<li>接收方将接收的数据（包括校验和字段）按发送方同样的方法进行1的补码和运算，累加的结果再取反码；</li>
<li>校验，如果上步的结果为0，表示传输正确；否则传输出错。</li>
</ul>
</li>
</ul>
<p>3）序号：TCP 连接中的数据流的每一个字节都编上一个序号，序号字段的值是指本报文段所发送的数据的第一个字节的序号</p>
<p>4）确认：TCP 首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。发送方缓冲区会存储那些已经发送但却未收到确认的报文段，以遍在需要时重传</p>
<p>5）重传：超时和冗余 ACK 都会导致 TCP 对报文段进行重传</p>
<ul>
<li>超时：TCP 每发送一个报文段，就对这个报文段设置一次计时器，计时器设置的重传时间到期但还没收到确认，就要重传这一报文段</li>
<li>冗余 ACK：超时触发重传存在的一个问题就是超时周期往往太长。发送方通常可以在超时事件发送之前通过注意所谓的冗余 ACK 来较好地检测丢包情况。冗余 ACK 就是再次确认某个报文段的 ACK，而发送方先前已经收到过该报文段的确认</li>
</ul>
<h5 id="6）TCP-流量控制："><a href="#6）TCP-流量控制：" class="headerlink" title="6）TCP 流量控制："></a>6）TCP 流量控制：</h5><ul>
<li>目的：消除发送方（发送速率太快）使接收方缓存区溢出的可能性</li>
<li>原理：在通信过程中，接收方根据自己接收缓存的大小，动态的调整发送方的发送窗口大小，称为接受窗口，即调整 TCP 报文段首部中的 “窗口” 字段值，来限制发送方向网络注入报文的速率</li>
</ul>
<h5 id="7）TCP-拥塞控制："><a href="#7）TCP-拥塞控制：" class="headerlink" title="7）TCP 拥塞控制："></a>7）TCP 拥塞控制：</h5><ul>
<li>目的：防止过多的数据注入网络，保证网络中的路由器或链路不至于过载</li>
<li>四种算法：<ul>
<li>慢开始：在 TCP 刚刚连接好并开始发送 TCP 报文段时，先令拥塞窗口等于1，即一个最大报文段长度。每收到一个对新报文段的确认后，将拥塞窗口加1，逐步增大发送方的拥塞窗口</li>
<li>拥塞避免：让拥塞窗口缓慢增大，每经过一个往返时延，就把发送方的拥塞窗口加一，而不是加倍，使得拥塞窗口线性缓慢增大</li>
<li>快重传：当发送方收到三个连续的 ACK 报文时，直接重传对方尚未收到的报文段，而不必等待报文段设置的重传计时器超时</li>
<li>快恢复：当发送方连续收到三个冗余 ACK（重复确认）后，把慢开始门限设置为此时发送方拥塞窗口的一半，为了预防网络发生拥塞。</li>
</ul>
</li>
</ul>
<h5 id="8）TCP-拥塞控制和流量控制的区别："><a href="#8）TCP-拥塞控制和流量控制的区别：" class="headerlink" title="8）TCP 拥塞控制和流量控制的区别："></a>8）TCP 拥塞控制和流量控制的区别：</h5><ul>
<li>拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素</li>
<li>流量控制是往往是指点对点的通信量的控制，是个端到端的问题（接受端控制发送端），它所要做的是抑制发送端发送数据的速率，使得接受端来得及接收</li>
</ul>
<p>9）滑动窗口有什么作用：</p>
<ul>
<li>滑动窗口协议，属于 TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。 该协议允许发送方在停止并等待确认前发送多个数据分组。 由于发送方不必每发一个分组就停下来等待确认。 因此该协议可以加速数据的传输，提高网络吞吐量 。 </li>
<li>如果过多的源同时以很快的速度发送大量的数据包，而此时接收方并没有如此高的接收数据的能力，因此极易导致网络的拥塞。 所以，为了控制发送方的发送速度，防止发送方并考虑到受发送缓冲区大小的制约等，要求对发送方已发出但尚未经确认的帧的数目加以限制，同时使网络的传输效率得到提高，滑动窗口协议应运而生，它使得发送方可以在未收到确认的情况下，同时发送多个数据分组，由此大大提升了网络吞吐量 。</li>
</ul>
<p>10）TCP 重要字段：</p>
<ul>
<li>序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li>
<li>确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</li>
<li>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等。<ul>
<li>URG：指示报文段里存在着被发送方的上层实体标记为”紧急”数据，当URG=1时，其后的紧急指针指示紧急数据在当前数据段中的位置(相对于当前序列号的字节偏移量)，TCP接收方必须通知上层实体。</li>
<li>ACK：当ACK=0时，表示该数据段不包含确认信息，当ACK=1时，表示该报文段包括一个对已被成功接收报文段的确认。</li>
<li>PSH：当PSH=1时，接收方在收到数据后立即将数据交给上层，而不是直到整个缓冲区满。</li>
<li>RST：用于重置一个已经混乱的连接(如主崩溃)，也可用于拒绝一个无效的数据段或者拒绝一个连接请求。一般而言，如果你得到的数据段被设置了RST位，那说明你这一端有问题了。</li>
<li>SYN：用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。注：捎带是指对客户机到服务器数据的确认被装载在一个承载服务器到客户机的数据</li>
<li>FIN：用于释放一个连接，表示发送方已经没有数据要传输了。此时，接收方可能继续接收数据，好在SYN和FIN数据段都有序列号，从而保证了这两种数据段以正确顺序被处理</li>
</ul>
</li>
</ul>
<p>11）套接字：</p>
<ul>
<li>用户认为的信息之间传输只是建立以两个应用程序上，实际上在TCP连接中是靠套接字来作为他们连接的桥梁。</li>
<li>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）表示，区分不同应用程序进程间的网络通信和连接,主要有3个参数：通信的目的IP地址、使用的传输层协议(TCP或UDP)和使用的端口号。</li>
</ul>
<p>12）TCP 字节流是什么：</p>
<ul>
<li>当发送端应用程序连续执行多次写操作时，TCP模块先将这些数据放入TCP发送缓冲区中。</li>
<li>当TCP模块真正发送数据时，发送缓冲区中等待发送的数据就可能被封装成一个或者多个TCP报文段发出。当接收端收到一个或者多个TCP报文段后，TCP模块将他们携带的应用程序数据按照TCP报文段的序号依次放入TCP接收缓冲区中，并通知应用程序读取数据。</li>
<li>接收端应用程序可以一次性将TCP接收缓冲区的数据全部读出，也可以分多次读取，这取决于用户指定的应用程序读缓冲区的大小。发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系。</li>
<li>这就是字节流的概念：应用程序对数据的发送和接收是没有边界限制的。</li>
</ul>
<p>13）Socket 的流程：</p>
<ul>
<li>服务器端：<ul>
<li>第一步：创建一个用于监听连接的Socket对像；</li>
<li>第二步：用指定的端口号和服务器的ip建立一个EndPoint对像；</li>
<li>第三步：用socket对像的Bind()方法绑定EndPoint；</li>
<li>第四步：用socket对像的Listen()方法开始监听；</li>
<li>第五步：接收到客户端的连接，用socket对像的Accept()方法创建一个新的用于和客户端进行通信的socket对像;</li>
<li>第六步：通信结束后一定记得关闭socket;</li>
</ul>
</li>
<li>客户端：<ul>
<li>第一步：建立一个Socket对像；</li>
<li>第二步：用指定的端口号和服务器的ip建立一个EndPoint对像；</li>
<li>第三步：用socket对像的Connect()方法以上面建立的EndPoint对像做为参数，向服务器发出连接请求；</li>
<li>第四步：如果连接成功，就用socket对像的Send()方法向服务器发送信息；</li>
<li>第五步：用socket对像的Receive()方法接受服务器发来的信息 ;</li>
<li>第六步：通信结束后一定记得关闭socket；</li>
</ul>
</li>
</ul>
<p>14）TCP 怎么处理数据包：</p>
<ul>
<li>首先，TCP模块会检查收到的包对应哪一个socket。在服务器端，可能有多个已连接的socket对应同一个端口号，因此仅根据接收方端口号无法找到特定的套接字。这时我们需要根据IP头部中的发送方IP地址和接收方IP地址，以及TCP头部中的接收方端口号和发送方端口号共4种信息，找到上述4种信息全部匹配的socket。</li>
<li>找到4种信息全部匹配的套接字之后，TCP模块会对比该套接字中保存的数据收发状态和收到的包的TCP头部中的信息是否匹配，以确定数据收发操作是否正常。具体来说，就是根据套接字中保存的上一个序号和数据长度计算下一个序号，并检查与收到的包的TCP头部中的序号是否一致。如果两者一致，就说明包正常到达了服务器，没有丢失。</li>
<li>当收到的数据进入接收缓冲区后，TCP模块就会生成确认应答的TCP头部，并根据接收包的序号和数据长度计算出ACK号，然后委托IP模块发送给客户端。</li>
</ul>
<p>15）TCP 报文格式：</p>
<ul>
<li><p>源端口和目的端口字段</p>
<ul>
<li>TCP源端口（Source Port）：源计算机上的应用程序的端口号，占 16 位。</li>
<li>TCP目的端口（Destination Port）：目标计算机的应用程序端口号，占 16 位。</li>
</ul>
</li>
<li><p>序列号字段：它表示本报文段所发送数据的第一个字节的编号。在 TCP 连接中，所传送的字节流的每一个字节都会按顺序编号。当SYN标记不为1时，这是当前数据分段第一个字母的序列号；如果SYN的值是1时，这个字段的值就是初始序列值（ISN），用于对序列号进行同步。这时，第一个字节的序列号比这个字段的值大1，也就是ISN加1。</p>
</li>
<li><p>确认号字段：它表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。其值是接收计算机即将接收到的下一个序列号，也就是下一个接收到的字节的序列号加1。</p>
</li>
<li><p>数据偏移字段：TCP 首部长度，数据偏移是指数据段中的“数据”部分起始处距离 TCP 数据段起始处的字节偏移量，占 4 位。其实这里的“数据偏移”也是在确定 TCP 数据段头部分的长度，告诉接收端的应用程序，数据从何处开始。</p>
</li>
<li><p>保留字段：保留（Reserved）：占 4 位。为 TCP 将来的发展预留空间，目前必须全部为 0。</p>
</li>
<li><p>标志位字段</p>
<ul>
<li>CWR（Congestion Window Reduce）：拥塞窗口减少标志，用来表明它接收到了设置 ECE 标志的 TCP 包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率。</li>
<li>ECE（ECN Echo）：用来在 TCP 三次握手时表明一个 TCP 端是具备 ECN 功能的。在数据传输过程中，它也用来表明接收到的 TCP 包的 IP 头部的 ECN 被设置为 11，即网络线路拥堵。</li>
<li>URG（Urgent）：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。</li>
<li>ACK：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1。</li>
<li>PSH（Push）：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即把数据提交给上层，而不是缓存起来。</li>
<li>RST：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。</li>
<li>SYN：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。</li>
<li>FIN：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接。</li>
</ul>
</li>
<li><p>窗口大小字段：窗口大小（Window Size）：占 16 位。它表示从 Ack Number 开始还可以接收多少字节的数据量，也表示当前接收端的接收窗口还有多少剩余空间。该字段可以用于 TCP 的流量控制。</p>
</li>
<li><p>TCP 校验和字段：校验位（TCP Checksum）：占 16 位。它用于确认传输的数据是否有损坏。发送端基于数据内容校验生成一个数值，接收端根据接收的数据校验生成一个值。两个值必须相同，才能证明数据是有效的。如果两个值不同，则丢掉这个数据包。Checksum 是根据伪头 + TCP 头 + TCP 数据三部分进行计算的。</p>
</li>
<li><p>紧急指针字段：紧急指针：仅当前面的 URG 控制位为 1 时才有意义。它指出本数据段中为紧急数据的字节数，占 16 位。当所有紧急数据处理完后，TCP 就会告诉应用程序恢复到正常操作。即使当前窗口大小为 0，也是可以发送紧急数据的，因为紧急数据无须缓存。</p>
</li>
<li><p>可选项字段：选项（Option）：长度不定，但长度必须是 32bits 的整数倍。</p>
</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>1）HTTP 协议的特点：</p>
<ul>
<li>支持客户/服务器模式</li>
<li>简单快速，服务器程序小</li>
<li>允许传输任何类型的数据</li>
<li>无连接，用于限制连接只处理一次请求</li>
<li>无状态，协议对事务处理没有记忆能力</li>
</ul>
<p>2）请求/响应的步骤：</p>
<ul>
<li>客户端连接 web 服务器</li>
<li>发送 HTTP 请求</li>
<li>服务器接受请求并返回 HTTP 响应</li>
<li>释放连接 TCP 连接</li>
<li>客户端浏览器解析 HTML 内容</li>
</ul>
<h5 id="3）向浏览器输入-URL，经历的流程是什么"><a href="#3）向浏览器输入-URL，经历的流程是什么" class="headerlink" title="3）向浏览器输入 URL，经历的流程是什么"></a>3）向浏览器输入 URL，经历的流程是什么</h5><ul>
<li>浏览器分析链接指向页面的 URL</li>
<li>浏览器向 DNS 解析 URL 的 IP 地址</li>
<li>浏览器与该服务器建立 TCP 连接（默认连接号为80）</li>
<li>浏览器发出 HTTP 请求</li>
<li>服务器解析 HTTP 请求，得知需要调度哪些资源，将结果通过 web 服务器返回给浏览器客户端</li>
<li>浏览器解析 HTML，渲染页面布局</li>
<li>关闭 TCP 连接</li>
</ul>
<p>4）浏览器渲染过程：</p>
<ul>
<li>浏览器渲染的过程主要包括以下五步：</li>
<li>浏览器将获取的HTML文档解析成DOM树。 </li>
<li>处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。 </li>
<li>将DOM和CSSOM合并为渲染树(rendering tree)，代表一系列将被渲染的对象。 </li>
<li>渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。 </li>
<li>将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting。</li>
</ul>
<h5 id="5）HTTP-状态码："><a href="#5）HTTP-状态码：" class="headerlink" title="5）HTTP 状态码："></a>5）HTTP 状态码：</h5><ul>
<li>1xx：部分请求已接收，通知客户端继续发送请求的剩余部分</li>
<li>2xx：表示请求已经成功接收<ul>
<li>200 OK：响应成功,请求已正常处理。</li>
<li>204 No Content：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</li>
<li>206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。</li>
</ul>
</li>
<li>3xx：要完成请求必须更进一步的操作<ul>
<li>301 Moved Permanently：资源的uri已更新，你也更新下你的书签引用吧。永久性重定向，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</li>
<li>302 Found：资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。</li>
<li>303 See Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。</li>
<li>304 Not Modified  : 客户端有缓存的文档,并发出了一个条件性的请求,服务器告诉客户端,原来有缓存的文档没有改变还可以继续使用( 减小带宽 )( 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 )</li>
</ul>
</li>
<li>4xx：请求有语法错误或者请求无法实现<ul>
<li>400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</li>
<li>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。该状态码必须和WWW-Authenticate报头域一起使用</li>
<li>403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</li>
<li>404 Not Found：服务器上没有请求的资源。路径错误等。</li>
</ul>
</li>
<li>5xx：服务器未能实现合法的请求<ul>
<li>500 Internal Server Error：该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</li>
<li>503 Service Unavailable：该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。( 请求未完成,服务器临时爆炸 )</li>
</ul>
</li>
</ul>
<h5 id="6）请求方法有哪些："><a href="#6）请求方法有哪些：" class="headerlink" title="6）请求方法有哪些："></a>6）请求方法有哪些：</h5><ul>
<li>GET：请求指定的页面信息，并返回实体主体</li>
<li>HEAD：类似于 GET 请求，用于获取报文头</li>
<li>POST：向指定资源提交数据处理请求（上传文件）</li>
<li>PUT：客户端向服务器传送的数据取代指定的内容</li>
<li>DELETE：请求服务器删除指定的页面</li>
<li>CONNECT：HTTP/1.1 协议中预留能够将连接改为管道方式的代理服务器</li>
<li>OPTIONS：允许客户端查看服务器的行能</li>
<li>TRACE：回显服务器收到的请求，主要用于测试和诊断</li>
</ul>
<h5 id="7）get-和-post-的区别："><a href="#7）get-和-post-的区别：" class="headerlink" title="7）get 和 post 的区别："></a>7）get 和 post 的区别：</h5><ul>
<li>post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）</li>
<li>post发送的数据更大（get有url长度限制）</li>
<li>post能发送更多的数据类型（get只能发送ASCII字符）</li>
<li>post比get慢<ul>
<li>post请求的过程：<ul>
<li>浏览器请求tcp连接（第一次握手）</li>
<li>服务器答应进行tcp连接（第二次握手）</li>
<li>浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</li>
<li>服务器返回100 Continue响应</li>
<li>浏览器发送数据</li>
<li>服务器返回200 OK响应</li>
</ul>
</li>
<li>get请求的过程：<ul>
<li>浏览器请求tcp连接（第一次握手）</li>
<li>服务器答应进行tcp连接（第二次握手）</li>
<li>浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</li>
<li>服务器返回200 OK响应</li>
</ul>
</li>
</ul>
</li>
<li>post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据</li>
</ul>
<p>8）get 请求和 post 请求的适用场景：</p>
<ul>
<li>当请求无副作用时（如进行搜索），便可使用GET方法；当请求有副作用时（如添加数据行），则用POST方法。一个比较实际的问题是：GET方法可能会产生很长的URL，或许会超过某些浏览器与服务器对URL长度的限制。</li>
<li>若符合下列任一情况，则用POST方法：<ul>
<li>请求的结果有持续性的副作用，例如，数据库内添加新的数据行。</li>
<li>若使用GET方法，则表单上收集的数据可能让URL过长。</li>
<li>要传送的数据不是采用7位的ASCII编码。</li>
</ul>
</li>
<li>若符合下列任一情况，则用GET方法：<ul>
<li>请求是为了查找资源，HTML表单数据仅用来帮助搜索。</li>
<li>请求结果无持续性的副作用。</li>
<li>收集的数据及HTML表单内的输入字段名称的总长不超过1024个字符。</li>
</ul>
</li>
</ul>
<p>9）为什么 GET 请求比 POST 请求快：</p>
<ul>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li>
<li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
<li>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
</ul>
<p>10）POST 请求的四种方式：</p>
<ul>
<li>POST 方法中对发送数据编码的方式，也就是 Content-Type 有四种方式，其中默认是 application/x-www-form-urlencoded，最方便的是 application/json 。四种方式包括：</li>
<li>application/x-www-form-urlencoded （URL encoded）：POST 中很常见的一种编码数据的方式，如果不设置 Content-type 的值，默认就是 urlencoded</li>
<li>multipart/form-data （键值对型数据）：这种编码方式，通常是用在客户端向服务端传送大文件数据，如：图片或者文件。首先会生成一个很长的 boundary 字符串分界线，表明下面的都是表单内容，然后紧接着跟的是表单中的第一个键值对中的名称，而后一个换行，跟着值。然后再生成一个boundary 字符串分界线，用于分割不同的键值。</li>
<li>application/json （Json 类型数据）：设置 header 中Content-type，就告诉服务端数据以 Json 字符串的形式存在，相应的就用 Json 的方法解码数据即可。</li>
<li>text/xml （xml）</li>
</ul>
<h5 id="11）HTTP-1-0-和-1-1-的区别："><a href="#11）HTTP-1-0-和-1-1-的区别：" class="headerlink" title="11）HTTP 1.0 和 1.1 的区别："></a>11）HTTP 1.0 和 1.1 的区别：</h5><ul>
<li>长连接：在 HTTP/1.0 中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP/1.1 默认使用长连接，可以来发多个请求</li>
<li>错误状态响应码：新增了24个错误状态响应码，409：表示请求的资源与资源的当前状态发生冲突；410：表示服务器上的某个资源被永久性删除了</li>
<li>缓存处理：HTTP1.1在缓存方面增加Cache-Control（HTTP1.0中存在Expires）、ETag（HTTP1.0中存在Last-Modified）和If-None-Match等请求头信息，使缓存更加灵活。</li>
<li>带宽优化以及网络连接的使用：HTTP 1.0 存在浪费带宽的现象，比如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。HTTP 1.1 在请求头加了 range 头域，它允许只请求资源的某个部分，状态码为 206</li>
</ul>
<h5 id="12）HTTP-2-0-和-1-1-的区别："><a href="#12）HTTP-2-0-和-1-1-的区别：" class="headerlink" title="12）HTTP 2.0 和 1.1 的区别："></a>12）HTTP 2.0 和 1.1 的区别：</h5><ul>
<li><p>多路复用：同一个连接并发处理多个请求，而且并发请求的数量比 HTTP 1.1 大了好几个数量级</p>
<ul>
<li><p>HTTP 2.0 多路复用的好处体现在哪里？</p>
<ul>
<li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li>
<li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li>
</ul>
</li>
</ul>
</li>
<li><p>二进制分帧：应用层和传输层之间增加了一个二进制分帧层。在二进制分帧层中，http2.0会将所有传输的信息分割为更小的消息和帧，并对他们进行二进制格式的编码。</p>
</li>
<li><p>首部压缩：http2.0使用encoder来减少需要传输的header的大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>
</li>
<li><p>服务器推送：服务端推送是一种在客户端请求之前发送数据的机制。在 HTTP 2.0 中，服务器可以对客户端的一个请求发送多个响应。</p>
</li>
</ul>
<p>13）URL 的组成：</p>
<ul>
<li>协议：模式/协议（scheme）,在Internet中可使用多种协议，如HTTP，FTP等。在”HTTP”后面的“//”为分隔符</li>
<li>域名：也可使用IP地址作为域名使用。</li>
<li>端口：不是一个URL必须的部分，如果省略端口部分，将采用默认端口。</li>
<li>虚拟目录：从域名后的第一个“/”开始到最后一个“/”为止。虚拟目录不是一个URL必须的部分。</li>
<li>文件名：从域名后的最后一个“/”至“？”(或“#”或至结束)为止，是文件名部分。文件名部分不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。</li>
<li>参数：从“？”开始到“#”（或至结束）为止之间的部分为参数部分，又称搜索部分、查询部分。参数间用“&amp;”作为分隔符。</li>
<li>锚：或称片段（fragment），HTTP请求不包括锚部分，从“#”开始到最后，都是锚部分。本例中的锚部分是“r_70732423“。锚部分不是一个URL必须的部分。锚点作用：打开用户页面时滚动到该锚点位置。</li>
</ul>
<p>14）URI和URL的区别：</p>
<ul>
<li><p>URI，是统一资源标识符，用来唯一的标识一个资源。</p>
<ul>
<li>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的</li>
<li>URI一般由三部组成：访问资源的命名机制；存放资源的主机名；资源自身的名称，由路径表示，着重强调于资源。</li>
</ul>
</li>
<li><p>URL，是统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p>
<ul>
<li>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。</li>
<li>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。</li>
<li>URL一般由三部组成：协议(或称为服务方式)；存有该资源的主机IP地址(有时也包括端口号)；主机资源的具体地址。如目录和文件名等</li>
</ul>
</li>
</ul>
<h5 id="15）Session-和-Cookie-的区别："><a href="#15）Session-和-Cookie-的区别：" class="headerlink" title="15）Session 和 Cookie 的区别："></a>15）Session 和 Cookie 的区别：</h5><ul>
<li>cookie数据保存在客户端，session数据保存在服务端。</li>
<li>session：当你登陆一个网站的时候，如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。</li>
<li>sessionid是服务器和客户端连接时候随机分配的，如果浏览器使用的是cookie，那么所有数据都保存在浏览器端，比如你登陆以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用cookie被攻击的可能性比较大。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/625d29e7239250f7c50864d1.jpg"></p>
<ul>
<li><strong>cookie原理</strong> : 当客户端访问服务器的时候（服务器运用了cookie），服务器会生成一份cookie传输给客户端，客户端会自动把cookie保存起来，以后客户端每次访问服务器，都会自动的携带着这份cookie。</li>
<li><strong>session原理</strong>: 当客户端第一次请求服务器的时候，服务器根据客户端信息生成一份session保存在服务端，将该数据(session)的id以cookie的形式传递给客户端；以后的每次请求，浏览器都会自动的携带cookie来访问服务器(session数据id)。直接去对应session查找该客户信息</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/625d2b7c239250f7c50cb477.jpg"></p>
<ul>
<li><p>cookie和session都是用来跟踪浏览器用户身份的会话方式。</p>
</li>
<li><h3 id="cookie和session区别"><a href="#cookie和session区别" class="headerlink" title="cookie和session区别"></a>cookie和session区别</h3><ul>
<li>cookie是保存在客户端的,容易被篡改</li>
<li>cookie有大小限制,4KB</li>
<li>session是保存在服务器端,更加安全</li>
<li>session会比较占用服务器性能，当访问增多时应用cookie</li>
</ul>
</li>
</ul>
<p>16）常见的首部：</p>
<ul>
<li>通用首部字段（请求报文与响应报文都会使用的首部字段）<ul>
<li>Date：创建报文时间</li>
<li>Connection：连接的管理</li>
<li>Cache-Control：缓存的控制</li>
<li>Transfer-Encoding：报文主体的传输编码方式</li>
</ul>
</li>
<li>请求首部字段（请求报文会使用的首部字段）<ul>
<li>Host：请求资源所在服务器</li>
<li>Accept：可处理的媒体类型</li>
<li>Accept-Charset：可接收的字符集</li>
<li>Accept-Encoding：可接受的内容编码</li>
<li>Accept-Language：可接受的自然语言</li>
</ul>
</li>
<li>响应首部字段（响应报文会使用的首部字段）<ul>
<li>Accept-Ranges：可接受的字节范围</li>
<li>Location：令客户端重新定向到的URI</li>
<li>Server：HTTP服务器的安装信息</li>
</ul>
</li>
</ul>
<h5 id="17）HTTP-报文的结构："><a href="#17）HTTP-报文的结构：" class="headerlink" title="17）HTTP 报文的结构："></a>17）HTTP 报文的结构：</h5><ul>
<li>HTTP的报文由三部分组成：开始行、首部行、实体主体。</li>
<li>开始行：区分请求报文与响应报文<ul>
<li>请求报文的开始行：由方法，URL，HTTP 版本组成<ul>
<li>方法：向请求资源指定的资源发送请求报文的方法，其作用是可以指定请求的资源按期望产生某种行为。</li>
<li>URL：链接</li>
<li>HTTP版本：目前有 HTTP/1.0、HTTP/1.1、HTTP/2.0 版本，其中 HTTP1.0 版本使用较广泛。</li>
</ul>
</li>
<li>响应报文的开始行：由 HTTP 版本，状态码组成。<ul>
<li>状态码都是三位数字的，分为 5 大类</li>
</ul>
</li>
</ul>
</li>
<li>首部行：是用来说明浏览器、服务器或报文主体的一些信息；可以有好几行，也可以不使用；每个首部行都是由首部字段名、和值组成；每个首部行在结束地方都有 CRLF（『回车』和『换行』符）<ul>
<li>HTTP 首部字段分为 4 种： 通用首部字段、请求首部字段、响应首部字段、实体首部字段。</li>
</ul>
</li>
<li>实体主体：在请求报文中，一般是 post/put 提交的表单信息。与首部行之间有 CRLF 即空行。</li>
</ul>
<h5 id="18）DNS-解析过程："><a href="#18）DNS-解析过程：" class="headerlink" title="18）DNS 解析过程："></a>18）DNS 解析过程：</h5><ul>
<li>用户主机上运行着DNS的客户端，就是我们的PC机或者手机客户端运行着DNS客户端了</li>
<li>浏览器将接收到的url中抽取出域名字段，就是访问的主机名, 并将这个主机名传送给DNS应用的客户端</li>
<li>DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式DNS集群的工作）</li>
<li>该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址</li>
<li>一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接</li>
</ul>
<h5 id="19）DNS-解析过程："><a href="#19）DNS-解析过程：" class="headerlink" title="19）DNS 解析过程："></a>19）DNS 解析过程：</h5><ul>
<li>递归查询<ul>
<li>第一步：在hosts静态文件、DNS解析器缓存中查找某主机的ip地址</li>
<li>第二步：上一步无法找到，去DNS本地服务器（即域服务器）查找，其本质是去区域服务器、服务器缓存中查找</li>
<li>第三步：本地DNS服务器查不到就根据‘根提示文件’向负责顶级域‘.com’的DNS服务器查询</li>
<li>第四步：‘根DNS服务器’根据查询域名中的‘xyz.com’，再向xyz.com的区域服务器查询</li>
<li>第五步：<a target="_blank" rel="noopener" href="http://www.xyz.abc.com的dns服务器直接解析该域名,将查询到的ip再原路返回给请求查询的主机/">www.xyz.abc.com的DNS服务器直接解析该域名，将查询到的ip再原路返回给请求查询的主机</a></li>
</ul>
</li>
<li>迭代查询<ul>
<li>第一步：在hosts静态文件、DNS解析器缓存中查找某主机的ip地址</li>
<li>第二步：上一步无法找到，在DNS本地服务器（即域服务器）查找所有本层次的区域服务器</li>
<li>第三步：本地DNS服务器查不到就查询上一层次的所有区域服务器，以此类推直至根域名DNS服务器‘.’</li>
<li>第四步：到达根域名服务器后又向下查询，直至查到结果为止。</li>
</ul>
</li>
<li>迭代查询与递归查询结合：递归查询需要经过逐层查询才能获得查询结果，当查询具有许多层次的DNS结构时效率很低，所以一般采用两者相结合的查询方式。<ul>
<li>第一步：在hosts静态文件、DNS解析器缓存中查找某主机的ip地址</li>
<li>第二步：上一步无法找到，去DNS本地服务器（即域服务器）查找，其本质是去区域服务器、服务器缓存中查找</li>
<li>第三步：本地DNS服务器查不到就根据‘根提示文件’向负责顶级域‘.com’的根DNS服务器查询</li>
<li>第四步：根DNS服务器直接将其区域DNS服务器的ip地址返回给本地服务器，而不用再向xyz.com的区域服务器查询。</li>
<li>第五步：本地DNS服务器将结果返回给请求的主机</li>
</ul>
</li>
</ul>
<p>20）DNS 劫持是什么？如何解决？</p>
<ul>
<li>攻击者利用其他攻击手段，篡改了某个域名的解析结果，使得指向该域名的IP变成了另一个IP，导致对相应网址的访问被劫持到另一个不可达的或者假冒的网址，从而实现非法窃取用户信息或者破坏正常网络服务的目的。</li>
<li>如何解决：定期检查您的DNS设置是否已修改，并确保您的DNS服务器是安全的。</li>
</ul>
<p>21）DNS TTL 是什么：</p>
<ul>
<li>用户访问该网站，并不是每次都会向DNS服务器上获取域名解析。比如用户第一次访问网站，会到DNS服务器上进行解析获取到对应的IP地址，用户从DNS服务器上获取的信息会缓存到当地的递归DNS服务器上。当第二个用户访问该网站时，递归服务器会直接返回解析结果，而不会再向DNS服务器请求解析。</li>
<li>TTL英文为Time To Live（生存时间），即域名解析的生存时间，也就是指域名的DNS解析记录在DNS服务器上的生存时间。建议设置600秒即可，因为阿里云默认的域名解析TTL值为10分钟，腾讯云默认的TTL值为600秒，二者都是10分钟就是600秒。</li>
</ul>
<p>22）能不能只用 TCP，不用 HTTP：</p>
<ul>
<li>TCP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</li>
<li>TCP/IP和HTTP协议的关系，从本质上来说，二者没有可比性，我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET 等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</li>
</ul>
<p>23）keep-alive 的用处：</p>
<ul>
<li>HTTP协议的keep-alive 意图在于复用TCP连接，同一个连接上串行方式传递请求-响应数据，在一个TCP连接上进行多次的HTTP请求从而提高性能。</li>
<li>TCP的keepalive机制意图在于保活、心跳，检测连接错误。TCP连接被中间设备断开，客户端和服务端对此是得不到通知的。若某连接长时间没有数据交换，可能被丢弃。那一旦有数据需要传递，且此时连接已经被中介设备断开，应用程序没有及时感知的话，那么就会导致在一个无效的数据链路层面发送业务数据，结果就是发送失败。</li>
</ul>
<p>24）HTTP 缓存：</p>
<ul>
<li>当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。</li>
<li>常见的http缓存只能缓存get请求响应的资源，http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。</li>
<li>根据是否需要重新向服务器发起请求来分类，可分为(强制缓存，协商缓存)<ul>
<li>强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。</li>
<li>协商缓存：当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期还或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。如果数据有更新就会返回200状态码，服务器就会返回更新后的资源并且将缓存信息一起返回。</li>
</ul>
</li>
</ul>
<h5 id="25）HTTP-的长连接和短连接："><a href="#25）HTTP-的长连接和短连接：" class="headerlink" title="25）HTTP 的长连接和短连接："></a>25）HTTP 的长连接和短连接：</h5><ul>
<li><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。<br>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：Connection:keep-alive</p>
</li>
<li><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
</li>
<li><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
</li>
<li><p>使用场景：</p>
<ul>
<li>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</li>
<li>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</li>
</ul>
</li>
</ul>
<p>26）HTTP 代理服务器：</p>
<ul>
<li>HTTP代理服务器在TCP协议的1080(可设定)端口上等待客户连接的到来，当用户的浏览器试图连接真实WWW服务器时，将首先与HTTP代理服务器连接，并通知用户身份的认证方式(如果无安全控制则无这步)，然后继续将请求发往HTTP代理服务器。</li>
<li>HTTP代理服务器在收到连接时将创建一个新的线程(小服务者)以处理此连接，并在新线程中进行用户身份认证(如果需要)，然后接受客户的请求。如果请求的数据在缓冲区中，则将数据用HTTP协议发到客户进程，否则还需连接至相应的WWW服务器以获得所需数据。</li>
<li>在代理服务器获得所需数据后，就将此数据发回客户进程，与此同时，还将其登记并存入服务器的缓冲区，以备下次使用。缓冲区内的数据通常按一定的算法清除，一般按保存的时间长短处理。</li>
</ul>
<p>27）HTTP 消息头：</p>
<ul>
<li>HTTP消息头是在，客户端请求（Request）或服务器响应（Response）时传递的，位请求或响应的第一行，HTTP消息体（请求或响应的内容）是其后传输。HTTP消息头，以明文的字符串格式传送，是以冒号分隔的键/值对，如：Accept-Charset: utf-8，每一个消息头最后以回车符(CR)和换行符(LF)结尾。HTTP消息头结束后，会用一个空白的字段来标识，这样就会出现两个连续的CR-LF。</li>
</ul>
<p>28）心跳包：</p>
<ul>
<li>应用场景：在长连接下，有可能很长一段时间都没有数据往来。理论上说，这个连接是一直保持连接的，但是实际情况中，如果中间节点出现什么故障是难以知道的。更要命的是，有的节点（防火墙）会自动把一定时间之内没有数据交互的连接给断掉。在这个时候，就需要我们的心跳包了，用于维持长连接，保活</li>
<li>什么是心跳机制：就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息如果服务端几分钟内没有收到客户端信息则视客户端断开。<ul>
<li>发包方：可以是客户也可以是服务端，看哪边实现方便合理。 心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。</li>
</ul>
</li>
<li>心跳包的发送，通常有两种技术：<ul>
<li>应用层自己实现的心跳包：由应用程序自己发送心跳包来检测连接是否正常，服务器每隔一定时间向客户端发送一个短小的数据包，然后启动一个线程，在线程中不断检测客户端的回应， 如果在一定时间内没有收到客户端的回应，即认为客户端已经掉线；同样，如果客户端在一定时间内没有收到服务器的心跳包，则认为连接不可用。</li>
<li>使用 SO_KEEPALIVE 套接字选项：在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项. 不论是服务端还是客户端，一方开启KeepAlive功能后，就会自动在规定时间内向对方发送心跳包， 而另一方在收到心跳包后就会自动回复，以告诉对方我仍然在线。因为开启KeepAlive功能需要消耗额外的宽带和流量，所以TCP协议层默认并不开启默认的KeepAlive超时需要7,200，000 MilliSeconds， 即2小时，探测次数为5次。对于很多服务端应用程序来说，2小时的空闲时间太长。因此，我们需要手工开启KeepAlive功能并设置合理的KeepAlive参数</li>
</ul>
</li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>1）HTTPS 概述：HTTPS，超文本传输安全协议，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。</p>
<h5 id="2）HTTP-和-HTTPS-的区别："><a href="#2）HTTP-和-HTTPS-的区别：" class="headerlink" title="2）HTTP 和 HTTPS 的区别："></a>2）HTTP 和 HTTPS 的区别：</h5><ul>
<li>HTTPS 需要去 CA 申请证书，HTTP 不需要</li>
<li>HTTPS 密文传输，HTTP 明文传输</li>
<li>连接方式不同，HTTPS 默认使用 443 端口，HTTP 使用 80 端口</li>
</ul>
<h5 id="3）HTTPS-工作原理："><a href="#3）HTTPS-工作原理：" class="headerlink" title="3）HTTPS 工作原理："></a>3）HTTPS 工作原理：</h5><ul>
<li><p>client向server发送请求，然后连接到server的443端口。</p>
</li>
<li><p>传送证书：这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。（服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。）</p>
</li>
<li><p>客户端解析证书：这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。</p>
</li>
<li><p>传送加密信息：这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>
</li>
<li><p>服务端加密信息：服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。</p>
</li>
<li><p>传输加密后的信息：这部分信息是服务端用密钥（随机值）对称加密后的信息，可以在客户端被还原。</p>
</li>
<li><p>客户端解密信息：客户端用之前生成的密钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。</p>
</li>
</ul>
<h5 id="4）SSL四次握手建立连接"><a href="#4）SSL四次握手建立连接" class="headerlink" title="4）SSL四次握手建立连接"></a>4）SSL四次握手建立连接</h5><ul>
<li>一次握手：<ul>
<li>客户端通过发送 Client Hello 报文开始 SSL通信。 报文中包含客户端支持的 SSL的指定版本、 加密组件（Cipher Suite） 列表（所使用的加密算法及密钥长度等） 。</li>
</ul>
</li>
<li>二次握手：<ul>
<li>服务器可进行 SSL通信时， 会以 Server Hello 报文作为应答。 和客户端一样， 在报文中包含 SSL版本以及加密组件。 服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li>
<li>之后服务器发送 Certificate 报文。 报文中包含公开密钥证书。</li>
<li>最后服务器发送 Server Hello Done 报文通知客户端， 最初阶段的 SSL握手协商部分结束。</li>
</ul>
</li>
<li>三次握手：<ul>
<li>客户端以 Client Key Exchange 报文作为回应。 报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。 该报文已用步骤 3 中的公开密钥进行加密。</li>
<li>接着客户端继续发送 Change Cipher Spec 报文。 该报文会提示服务器， 在此报文之后的通信会采用Pre-master secret 密钥加密。</li>
<li>客户端发送 Finished 报文。 该报文包含连接至今全部报文的整体校验值。 这次握手协商是否能够成功， 要以服务器是否能够正确解密该报文作为判定标准。</li>
</ul>
</li>
<li>四次握手：<ul>
<li>服务器同样发送 Change Cipher Spec 报文。</li>
<li>服务器同样发送 Finished 报文。</li>
</ul>
</li>
<li>总的来说，SSL会话的建立完成了以下几个工作：交换协议版本号，选择一个通信双方都支持的加密方式；对两端实现身份验证；密钥交换。</li>
</ul>
<p>精简版：</p>
<ul>
<li>协商加密算法：浏览器向服务器发送浏览器的 SSL 版本号和一些可供选择的加密算法。服务器从中选定自己所支持的算法，并告知浏览器</li>
<li>服务器鉴别：服务器向浏览器发送包含公钥的数字证书。浏览器使用该证书的认证机构 CA 公开发布的公钥对该证书进行验证</li>
<li>会话密钥计算：浏览器随机生成一个秘密数，用服务器的公钥进行加密后发给服务器，双方根据协商的算法产生会话密钥</li>
<li>安全数据传输：双方用会话密钥加密和解密它们之间传送的数据并验证其完整性。</li>
</ul>
<h5 id="5）对称加密和非对称加密："><a href="#5）对称加密和非对称加密：" class="headerlink" title="5）对称加密和非对称加密："></a>5）对称加密和非对称加密：</h5><ul>
<li>对称加密算法的加密和解密都是用同一个密钥。如果通信双方都各自持有同一个密钥，且没有别人知道，则两方的通信安全是可以被保证的（除非密钥被破解）。然而，最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，这个传输过程中密钥被别人劫持，之后他就能用密钥解开双方传输的任何内容。<ul>
<li>DES：数据加密标准，速度较快，适用于加密大量数据的场合。</li>
<li>3DES：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</li>
<li>AES：高级加密标准，是下一代的加密算法标准，速度快，安全级别高；</li>
</ul>
</li>
<li>基于对称加密存在的问题，又有了非对称加密。非对称加密算法需要一组密钥对，分别是公钥和私钥，这两个密钥是成对出现的。公钥加密的内容需要对应的私钥解密，私钥加密的内容需要对应的公钥解密。私钥由服务器自己保存，公钥发送给客户端。客户端拿到公钥后可以对请求进行加密后发送给服务端，这时候就算中间被截获，没有私钥也无法解密发送的内容，这样确保了客户端发送到服务端数据的安全。<ul>
<li>RSA：RSA加密是对明文的E次方后除以N后求余数的过程；N是RSA加密的密钥，也就是说E和N的组合就是公钥，我们用(E,N)来表示公钥。对密文进行D次方后除以N的余数就是明文，这就是RSA解密过程。知道D和N就能进行解密密文了，所以D和N的组合就是私钥。</li>
<li>DSA：数字签名算法，是一种标准的 DSS（数字签名标准）；</li>
<li>ECC：椭圆曲线密码编码学。</li>
</ul>
</li>
<li>当我们需要加密大量的数据时，建议采用对称加密算法，提高加解密速度。</li>
</ul>
<p>6）通过一组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，是不是就能保证双向传输都安全了？HTTPS的加密却没使用这种方案，为什么？</p>
<ul>
<li>可以保证安全，但HTTPS没有使用的最主要原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心。而对称加密快很多。</li>
</ul>
<h5 id="7）非对称加密和对称加密结合的方式是什么？什么是中间人攻击？"><a href="#7）非对称加密和对称加密结合的方式是什么？什么是中间人攻击？" class="headerlink" title="7）非对称加密和对称加密结合的方式是什么？什么是中间人攻击？"></a>7）非对称加密和对称加密结合的方式是什么？什么是中间人攻击？</h5><ul>
<li><p>非对称加密、解密各只需一次的方法：</p>
<ul>
<li>某网站拥有用于非对称加密的公钥A1、私钥A2。</li>
<li>浏览器向网站服务器请求，服务器把公钥A1明文给传输浏览器。</li>
<li>浏览器随机生成一个用于对称加密的密钥X，用公钥A1加密后传给服务器。</li>
<li>服务器拿到后用私钥A2解密得到密钥X。</li>
<li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可。</li>
</ul>
</li>
<li><p>中间人的确无法得到浏览器生成的对称密钥X，这个密钥本身被公钥A1加密，只有服务器才能用私钥A2进行解密。然而中间人却完全不需要拿到私钥A2就能劫持信息，请看：</p>
<ul>
<li><p>在第二步中，中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）。</p>
</li>
<li><p>浏览器随机生成一个用于对称加密的密钥X，用公钥B1（浏览器不知道公钥被替换了）加密后传给服务器。</p>
</li>
<li><p>中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器。</p>
</li>
<li><p>服务器拿到后用私钥A2解密得到密钥X。</p>
</li>
<li><p>这样在双方都不会发现异常的情况下，中间人得到了对称密钥X。根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。</p>
</li>
</ul>
</li>
</ul>
<p>8）如何防止中间人用自己的证书替换</p>
<ul>
<li>网站在使用HTTPS前，需要向“CA机构”申请颁发一数字证书，数字证书里有证书持有者、证书持有者的公钥等信息。服务器把证书传输给浏览器，浏览器从证书里取公钥就可以了。</li>
<li>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</li>
</ul>
<p>9）数字证书：网站在使用HTTPS前，需要向“CA机构”申请颁发一数字证书，数字证书里有证书持有者、证书持有者的公钥等信息。服务器把证书传输给浏览器，浏览器从证书里取公钥就可以了。</p>
<p>10）证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？数字证书怎么防伪呢？</p>
<ul>
<li>我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫数字签名。</li>
<li>数字签名的制作过程：CA拥有非对称加密的私钥和公钥；CA对证书明文信息进行hash；对hash后的值用私钥加密，得到数字签名。</li>
<li>浏览器验证过程：拿到证书，得到明文和数字签名。用CA机构的公钥对数字签名解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。）；用证书里说明的hash算法对明文进行hash，比较刚才两个结果是否相同，等于则表明证书可信。</li>
</ul>
<p>11）为什么这样可以证明证书可信？</p>
<ul>
<li>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</li>
</ul>
<p>12）既然不可能篡改，那如果整个证书被掉包呢？</p>
<ul>
<li>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</li>
</ul>
<p>13）制作数字签名时为什么需要hash一次？</p>
<ul>
<li>非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。当然除此之外也有安全上的原因。</li>
</ul>
<p>14）HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？</p>
<ul>
<li>显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？用session就可以。服务器会为每个浏览器（或客户端软件）维护一个session ID，握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了。</li>
</ul>
<p>15）Https如何防止篡改：</p>
<ul>
<li>我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫数字签名。</li>
<li>数字签名的制作过程：CA拥有非对称加密的私钥和公钥；CA对证书明文信息进行hash；对hash后的值用私钥加密，得到数字签名。</li>
<li>浏览器验证过程：拿到证书，得到明文和数字签名。用CA机构的公钥对数字签名解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。）；用证书里说明的hash算法对明文进行hash，比较刚才两个结果是否相同，等于则表明证书可信。</li>
</ul>
<p>16）MD5的功能：</p>
<ul>
<li>输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）；</li>
<li>不同的输入得到的不同的结果（唯一性）；</li>
<li>根据128位的输出结果不可能反推出输入的信息（不可逆），也就是只能加密，不能解密；** </li>
</ul>
<p>17）为什么 MD5 要加盐：</p>
<ul>
<li> 盐（Salt）在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</li>
<li> 收集常用的密码，然后对他们执行 MD5 或者 SHA1，然后做成一个数据量非常庞大的数据字典，然后对泄露的数据库中的密码就行对比，如果原始密码被包含在这个数据字典中，那么花不了多长时间就能把原始密码匹配出来，依然是不安全</li>
<li> Salt 可以是任意字母、数字、或是字母或数字的组合，但必须是随机产生的，每个用户的 Salt 都不一样。由于加了 Salt，即便数据库泄露了，但是由于密码都是加了 Salt 之后的散列，坏人们的数据字典已经无法直接匹配，明文密码被破解出来的概率也大大降低。</li>
</ul>

      </section>

      
      
        <nav class="article-nav">
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
      <div class="card-cover" background-image-lazy data-img="https://pic.imgdb.cn/item/61299da544eaada7390fc89c.png"></div>
    
    <div class="card-text">
      
        <a href="/2021/08/28/egg/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">egg</h2>
        </a>
      
      <div class="card-text--row">Newer</div>
    </div>
  </article>
</div>
          
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
      <div class="card-cover" background-image-lazy data-img="https://pic.imgdb.cn/item/6122fefb44eaada739232a12.jpg"></div>
    
    <div class="card-text">
      
        <a href="/2021/08/23/%E5%AE%89%E5%85%A8-%E6%80%A7%E8%83%BD/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">安全&amp;性能</h2>
        </a>
      
      <div class="card-text--row">Older</div>
    </div>
  </article>
</div>
          
        </nav>
      

      <section class="page-message-container layout-padding">
        


  
  

  
  


      </section>
    </div>
    <div class="widget-info">
      <section class="widget-author widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-body">
    
      <img src="https://pic.imgdb.cn/item/60f1777e5132923bf8ac2700.jpg" class="soft-size--round soft-style--box" alt="横道世之介">
    
    
      <h2>横道世之介</h2>
    
    
      <p>确实还好</p>
    

    <div class="count-box">
      <div class="count-box--item">
        <svg class="icon icon-article" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M240.51564747 647.74217627h196.07203239c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806V165.10332731c0-33.18142087-30.16492806-60.32985613-60.32985612-60.32985611H245.04038668C225.43318342 104.7734712 210.35071939 119.85593522 210.35071939 139.46313845V617.57724821c0 16.59071043 13.57421762 30.16492806 30.16492808 30.16492806z m663.62841731-452.47392089v482.63884894c0 33.18142087-27.14843525 60.32985613-60.32985612 60.32985613H180.18579134c-33.18142087 0-60.32985613-27.14843525-60.32985612-60.32985613V195.26825538c-49.77213131 0-90.49478418 40.72265287-90.49478417 90.49478417v452.4739209c0 49.77213131 40.72265287 90.49478418 90.49478417 90.49478417h286.56681657c16.59071043 0 30.16492806 13.57421762 30.16492807 30.16492807s13.57421762 30.16492806 30.16492805 30.16492806h90.49478418c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806s13.57421762-30.16492806 30.16492807-30.16492807h286.56681657c49.77213131 0 90.49478418-40.72265287 90.49478417-90.49478417V285.76303955c0-49.77213131-40.72265287-90.49478418-90.49478417-90.49478417zM587.41232014 647.74217627h191.54729318c19.60720323 0 34.68966726-15.08246403 34.68966729-34.68966727V134.93839925c0-16.59071043-13.57421762-30.16492806-30.16492808-30.16492805H617.57724821c-30.16492806 0-60.32985613 27.14843525-60.32985612 60.32985611v452.4739209c0 16.59071043 13.57421762 30.16492806 30.16492805 30.16492806z" fill="currentColor"></path>
</svg>
        <span>16</span>
      </div>
      <div class="count-box--item">
        <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
        0
      </div>
      <div class="count-box--item">
        <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
        6
      </div>
    </div>
  </div>
</section>

      

      
<section class="widet-notice widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-notice" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M512 945.02305225v28.15620663a24.27259221 24.27259221 0 0 1-24.27259221 24.27259335H394.0352a48.54518557 48.54518557 0 0 1-41.74885888-23.78714112l-110.68302222-184.47170332a132.04290333 132.04290333 0 0 1-17.47626667-48.54518557h118.4502511a200.97706667 200.97706667 0 0 1 76.21594113 14.56355556l20.38897777 133.49925888a48.54518557 48.54518557 0 0 0 36.40888888 27.67075555l16.01991111 2.91271112a24.27259221 24.27259221 0 0 1 20.38897778 25.72894889zM997.45185223 463.45481443a194.18074112 194.18074112 0 0 1-38.8361489 116.50844445 24.75804445 24.75804445 0 0 1-36.4088889 0l-34.95253333-34.95253333a24.27259221 24.27259221 0 0 1-2.91271111-30.58346667 97.09036999 97.09036999 0 0 0 0-106.79940665 24.27259221 24.27259221 0 0 1 2.91271111-30.58346666l34.95253333-34.95253334a24.75804445 24.75804445 0 0 1 18.93262223-7.28177777 26.2144 26.2144 0 0 1 17.47626667 9.70903665A194.18074112 194.18074112 0 0 1 997.45185223 463.45481443z m-194.18074112-388.36148111v776.72296335a48.54518557 48.54518557 0 0 1-48.54518556 48.54518443h-28.64165888a48.54518557 48.54518557 0 0 1-33.98163001-14.07810332l-145.63555556-143.20829668A291.27111111 291.27111111 0 0 0 342.57730333 657.63555556H172.18370333a145.63555556 145.63555556 0 0 1-145.63555556-145.63555556v-97.09036999a145.63555556 145.63555556 0 0 1 145.63555556-145.63555556h170.3936a291.27111111 291.27111111 0 0 0 206.31703779-85.43952668l145.63555555-143.20829554a48.54518557 48.54518557 0 0 1 33.98162888-14.07810446H754.72592555a48.54518557 48.54518557 0 0 1 48.54518556 48.54518555z" fill="currentColor"></path>
</svg>
    <span>NOTICE</span>
  </div>
  <div class="widget-body">
    <p>flex-block主题部分重构，详情查看https://github.com/miiiku/flex-block</p>
  </div>
</section>


      <section class="widget-categorys widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
    <span>CATEGORYS</span>
  </div>
  <div class="widget-body">
    <ul class="categorys-list">
      
    </ul>
  </div>
</section>

      <section class="widget-tags widget-item  layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
    <span>TAGS</span>
  </div>
  <div class="widget-body">
    <div class="tags-cloud">
      <a href="/tags/Ajax/" style="font-size: 10px;" class="tags-cloud-0">Ajax</a> <a href="/tags/CSS/" style="font-size: 10px;" class="tags-cloud-0">CSS</a> <a href="/tags/http/" style="font-size: 10px;" class="tags-cloud-0">http</a> <a href="/tags/js%E5%9F%BA%E7%A1%80/" style="font-size: 20px;" class="tags-cloud-10">js基础</a> <a href="/tags/node/" style="font-size: 10px;" class="tags-cloud-0">node</a> <a href="/tags/%E5%AE%89%E5%85%A8-%E6%80%A7%E8%83%BD/" style="font-size: 10px;" class="tags-cloud-0">安全&性能</a>
    </div>
  </div>
</section>
    </div>
  </article>
</div>

                <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    
    <div class="social-icons">
      
        
      
        
      
        
      
        
          <a href="https://github.com/FlowerAndAlice/" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
</svg>
          </a>
        
      
        
      
    </div>
     
    <p>&copy; 2022 <a href="/" target="_blank">广工彭于晏</a></p>

    

    <p>Powered by <a href="https://hexo.io" target="_blank" rel="noopener noreferrer">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank" rel="noopener noreferrer author">flex-block</a></p>

    <p>
      <a href="javascript:;" id="theme-light">🌞 浅色</a>
      <a href="javascript:;" id="theme-dark">🌛 深色</a>
      <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
    </p>
  </div>
</footer>
    </div>

    <div class="back-to-top-fixed soft-size--round soft-style--box">
        <svg class="icon icon-back-to-top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <path d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"></path>
      <path d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"></path>
      <path d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"></path>
    </svg>
    </div>

    
        <!-- aplayer -->


<!-- dplayer -->




  


  


  




<script src="/js/script.js"></script>


            
                <!-- 尾部用户自定义相关内容 -->
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/haru01.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>